<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Komplexit&auml;tsklassen in der Informatik: Ein &Uuml;berblick</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="site">
          <div class="header">
            <h1 class="title"><a href="/">Martin Thoma</a></h1>
            <a class="extra" href="/">home</a>
          </div>

          <h2>Komplexit&auml;tsklassen in der Informatik: Ein &Uuml;berblick</h2>
<p class="meta">16 Feb 2012</p>

<div class="post">
<p>Komplexit&auml;tsklassen werden in der Theoretischen Informatik verwendet um den Ressourcenbedarf von Algorithmen bzw. Problemen einzuordnen. Meist betrachtet man die Laufzeit- und die Speicherplatzkomplexit&auml;t, aber es w&auml;re prinzipiell auf Vorstellbar, dass man andere Kriterien nutzt. Ich werde in diesem Artikel mal kurz die in der Vorlesung behandelten Klassen vorstellen.</p>

<p>Da es umst&auml;ndlich ist, werde ich im Folgenden nur noch von Problemen reden. Gemeint sind aber meist auch formale Sprachen und Algorithmen.</p>

<h2>Die Klasse P</h2>


<p>In der Klasse $\cal P$ sind alle Probleme, die mit einer deterministischen Turingmaschine in polynomialzeit l&ouml;sbar sind. Das sind also alle Probleme, f&uuml;r die es einen Algorithmus gibt, der in $\cal O(n<sup>i</sup>), i \in \mathbb{N}_0$ ist.</p>

<p>Wenn es allerdings <em>noch</em> keinen Algorithmus gibt, der ein Problem in polynomialzeit l&ouml;st, kann das Problem dennoch in $\cal P$ liegen. Dann muss es einen besseren Algorithmus zur L&ouml;sung des Problems geben.</p>

<h2>Die Klasse NP</h2>


<p>In der Klasse $\cal NP$ sind alle Probleme, die mit einer <strong>nicht-deterministischen</strong> Turingmaschine in polynomialzeit l&ouml;sbar sind. Das besondere an einer nicht-determinisitschen Turingmaschine ist das Orakelmodul. Es liefert einfach die L&ouml;sung. Wie es das macht, wissen wir nicht. Irgendwie geht es halt. Diese L&ouml;sung muss in polynomialzeit von einer deterministischen Turingmaschine verifiziert werden.</p>

<p>Was liegt dann nicht in $\cal NP$? Das Orakelmodul h&ouml;rt sich so m&auml;chtig an, dass eventuell alle Probleme in $\cal NP$ liegen k&ouml;nnten. Weit gefehlt. Suchprobleme liegen h&auml;ufig (aber nicht immer) au&szlig;erhalb von $\cal NP$. Das sind dann Probleme mit einer Fragestellung &agrave; la "Gib eine optimale Tour durch eine gegebene Menge an St&auml;dten an". Wenn das Orakel-Modul eine solche Tour liefert, muss der deterministische Teil noch schauen, ob es eventuell eine l&auml;ngere Tour gibt.</p>

<p>Die wohl ber&uuml;hmteste Fragestellung der Theoretischen Informatik lautet nun:</p>

<p><strong>P vs. NP</strong>: Gibt es Probleme, die in NP liegen, aber nicht in P?</p>

<p>Es ist wohl anschaulich klar, dass gilt: $\cal P \subset NP$. P vs. NP ist die Frage, ob $\cal P = NP$ oder $\cal P \subsetneq NP$. Oder nochmals anders formuliert: $\cal NP \setminus P \stackrel{?}{=} \emptyset$</p>

<h3>Die Klasse NPC</h3>


<p>Die Klasse der NP-Vollst&auml;ndigen Probleme ist echt in NP, also $\cal NPC \subsetneq NP$. Das besondere an $\cal NPC$ ist, dass jedes Probleminstanz in $\cal NP$ in eine Instanz eines beliebigen Problems in $\cal NPC$ umgewandelt werden kann.</p>

<p>Das es ein solches Problem gibt, hat Cook 1971 mit <a href="http://de.wikipedia.org/wiki/Erf%C3%BCllbarkeitsproblem_der_Aussagenlogik">SAT</a> gezeigt. Cook hat also anschaulich folgendes gemacht:
[caption id="attachment_15231" align="aligncenter" width="387" caption="SAT ist in NPC"]<a href="http://martin-thoma.com/wp-content/uploads/2012/02/npc-sat.png"><img src="http://martin-thoma.com/wp-content/uploads/2012/02/npc-sat.png" alt="SAT ist in NPC" title="SAT ist in NPC" width="387" height="313" class="size-full wp-image-15231" /></a>[/caption]</p>

<p>F&uuml;r alle folgenden Beweise, dass ein Problem in $\cal NPC$ liegt, wurde der Satz von Cook verwendet.
Laut diesem Satz (dessen Beweis wahnsinning lang ist) l&auml;sst sich jede Probleminstanz von Problemen in $\cal NP$ sich in eine Instanz von SAT umwandeln. Es reicht also zu zeigen, dass sich eine beliebige SAT-Instanz I  in eine Instanz I' des neuen Problems in polynomialzeit umwandeln l&auml;sst. Diese beiden Instzanzen m&uuml;ssen in folgender Beziehung stehen:
F&uuml;r I existiert eine L&ouml;sung $\Leftrightarrow$ f&uuml;r I' existiert eine L&ouml;sung:
[caption id="attachment_15241" align="aligncenter" width="460" caption="Beweis, dass 3-SAT in NPC liegt"]<a href="http://martin-thoma.com/wp-content/uploads/2012/02/proof-new-npc.png"><img src="http://martin-thoma.com/wp-content/uploads/2012/02/proof-new-npc.png" alt="Beweis, dass 3-SAT in NPC liegt" title="Beweis, dass 3-SAT in NPC liegt" width="460" height="354" class="size-full wp-image-15241" /></a>[/caption]</p>

<p>Sobald man von einem Problem sicher wei&szlig;, dass es in $\cal NPC$ liegt, kann man nat&uuml;rlich auch etwas anderes als SAT verwenden.</p>

<p>Im Bezug auf P vs. NP ist es vor allem interessant. Wenn ein Problem nicht in P, aber in NP liegt, dann ist sicher jedes Problem in NPC au&szlig;erhalb von P. Also: $\cal P \neq NP \Rightarrow P \cap NPC = \emptyset$.
Warum? Angenommen es existiert ein Problem P f&uuml;r das gilt:</p>

<ul>
  <li>$P \in \cal NP$</li>
  <li>$P \notin \cal P$</li>
  <li>$P \notin \cal NPC$</li>
</ul>


<p>Dann gibt es eine polynomielle Transformation von jeder Instanz von P in eine Probleminstanz von einem beliebigem Problem in $\cal NPC$. Damit kann jedes Problem in $\cal NPC$ nicht mehr in $\cal P$ liegen, da sonst auch $P \in \cal P$.</p>

<h2>NPI, co-P und co-NP</h2>


<p>Formal gilt: $\cal NPI := NP \setminus (P \cup NPC)$.
Es sind also alle Probleme, die innerhalb von $\cal NP$ sind, aber au&szlig;erhalb von $\cal P$ und noch nicht in $\cal NPC$ in $\cal NPI$. Es ist also so eine Art "Zwischenklasse".</p>

<p>Um es etwas anschaulicher zu machen, habe ich mal folgendes Bildchen erstellt:
[caption id="attachment_14511" align="aligncenter" width="500" caption="P vs. NP: Die Klassen P, NP, NPC und NPI im &Uuml;berblick"]<a href="http://martin-thoma.com/wp-content/uploads/2012/02/PvsNP.png"><img src="http://martin-thoma.com/wp-content/uploads/2012/02/PvsNP.png" alt="P vs. NP: Die Klassen P, NP, NPC und NPI im &Uuml;berblick" title="P vs. NP: Die Klassen P, NP, NPC und NPI im &Uuml;berblick" width="500" height="400" class="size-full wp-image-14511" /></a>[/caption]</p>

<p>Bemerkenswert ist folgende Aussage:
Im Fall $\cal P = NP$ ist auch ${\cal P} \setminus {\emptyset, \Sigma^*} = {\cal NPC}$ (siehe Nachklausur von 2007 / 2008, Frage 5).
Warum stimmt das? Damit ein Problem $\in \cal NPC$ ist, muss es nur eine polynomielle Transformation von jedem Problem in NP auf das eine Problem geben. Das ist offensichtlich der Fall, wenn man alle Probleme in NP in polynomieller Zeit l&ouml;sen kann. In diesem Fall kann man das Entscheidungsproblem l&ouml;sen und eine Ja-Instanz auf eine beliebige andere Ja-Instanz abbilden und analog Nein-Instanzen auf Nein-Instanzen abbilden. Da $\emptyset$ keine Ja-Instanz hat und $\Sigma$ keine Nein-Instanz hat, muss man diese herausnehmen.</p>

<p>Formal gilt: $\text{co-}{\cal P} := {L \in \Sigma^<em> | L<sup>C</sup> \in {\cal P}}$ und analog $\text{co-}{\cal NP} := {L \in \Sigma^</em> | L<sup>C</sup> \in {\cal NP}}$.</p>

<p>Folgende Aussage finde ich dazu sehr interessant:
$L \in {\cal NPC} \land L \in \text{co-}{\cal NP} \Rightarrow {\cal NP} = \text{co-}{\cal NP}$</p>

<h2>D-TAPE und N-TAPE</h2>


<p>Im Skript wurde das seltsam geschrieben ($\cal DTAPE$). Ich habe so nicht mehr erkannt, dass es TAPE hei&szlig;en soll. In der Klausur sollte man sich davon nicht irritieren lassen.</p>

<p>Formal: $D-TAPE(s(n)) := {L | \text{Es existiert eine determinitistische TM, die L mit Platzbedarf s(n) akzeptiert.}}$
$N-TAPE(s(n)) := {L | \text{Es existiert eine nicht-determinitistische TM, die L mit Platzbedarf s(n) akzeptiert.}}$</p>

<h2>Quellen und Material</h2>


<ul>
  <li><a href="http://i11www.iti.uni-karlsruhe.de/_media/teaching/winter2011/tgi/tgi_skript_ws11.pdf">Theoretische Grundlagen der Informatik</a>: Skript von Prof. Dr. Dorothea Wagner</li>
  <li>Die Bilder stehen hier zur Verf&uuml;gung: <a href='http://martin-thoma.com/wp-content/uploads/2012/02/komplexitaetsklassen-material.zip'>Material zu den Komplexit&auml;tsklassen</a></li>
</ul>



<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    processEscapes: true
  }
});
</script>
</div>

            <div class="footer">
    <div class="contact">
      <p>
        Martin<br />
        What You Are<br />
        you@example.com
      </p>
    </div>
    <div class="contact">
      <p>
        <a href="https://github.com/yourusername">github.com/yourusername</a><br />
        <a href="https://twitter.com/yourusername">twitter.com/yourusername</a><br />
      </p>
    </div>
  </div>

        </div>
    </body>
</html>
