<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Google Code Jam 2012 &ndash; Round 1B 2012</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="site">
          <div class="header">
            <h1 class="title"><a href="/">Martin Thoma</a></h1>
            <a class="extra" href="/">home</a>
          </div>

          <h2>Google Code Jam 2012 &ndash; Round 1B 2012</h2>
<p class="meta">05 May 2012</p>

<div class="post">
<p>5614 tried the first problem, but only 3281 people are listed in the scoreboard. So quite a lot tried to solve a problem, but couldn't even solve one. I think these problems were much harder than the ones from <a href="http://martin-thoma.com/google-code-jam-2012-round-1a-2012/" title="Google Code Jam 2012 &ndash; Round 1A 2012">Round 1A 2012</a>.</p>

<ul>
  <li>Problem 1 (<a href="http://code.google.com/codejam/contest/1836486/dashboard#s=p0">Safety in Numbers</a>):
  <ul>
     <li>Small Set: 2695/5614 users (48%)</li>
     <li>Large Set: 2016/2686 users (75%)</li>
  </ul>
  </li>
  <li>Problem 2 (<a href="http://code.google.com/codejam/contest/1836486/dashboard#s=p1">Tide Goes In, Tide Goes Out</a>):
  <ul>
     <li>Small Set: 684/894 users (77%)</li>
     <li>Large Set: 620/671 users (92%)</li>
  </ul>
  </li>
  <li>Problem 3 (<a href="http://code.google.com/codejam/contest/1836486/dashboard#s=p2">Equal Sums</a>):
  <ul>
     <li>Small Set: 2261/2534 users (89%)</li>
     <li>Large Set: 149/854 users (17%)</li>
  </ul>
  </li>
</ul>




<h2>Safety in Numbers</h2>


<p>I tried this approach:
X is the sum of all points given by judges. The visitors have an equal amount of points to give.
$P_i$ is the number of total points of contestant i.
$J_i$ is the number of points of contestant i by the judges.
$V_i$ is the percentage of the visitors points contestant i gets.</p>

<p>So: $P_i = J_i + V_i * X$</p>

<p>You don't know $V_i$ and $P_i$. You have to get the minimal value of $V_i$ to guarantee that contestant $i$ will not to be eliminated. So you have to create some kind of "worst case" for contestant i, if he gets $V_i \cdot X$ visitor-points. The worst case is that the minimum of all remaining visitors is as high as possible. So if you think of them as players, they will always try to get a equal number of points.</p>

<p>If they can get an equal number of points, you can make these (in)equations:
$average = (X - p_i)/(N-1)$
$p_i + V_i \cdot X \geq avg + \frac{1-V_i}{N-1} \cdot X$
$V_i \cdot X - \frac{1-V_i}{N-1}  \cdot X \geq avg - p_i$
$V_i X (N-1) - (1-V_i) \cdot X \geq (N-1) \cdot (avg - p_i)$
$V_i X (N-1) - X +V_i \cdot X \geq (N-1) \cdot (avg - p_i)$
$V_i X (N-1) +V_i \cdot X \geq (N-1) \cdot (avg - p_i) + X$
$V_i \geq (N-1) \cdot ((avg - p_i) + X)/(X (N-1) +X)$
$V_i \geq (N-1) \cdot ((avg - p_i) + X)/(X ((N-1) +1))$
$V_i \geq \frac{N-1}{X \cdot N} \cdot (avg - p_i + X)$</p>

<p>Unfortunately, its possible that the other players can't get an equal number of points. So this approach is useless in this case.</p>

<p>Here is an approach with an approximation, which also works for the large input set.
[cpp]#include <iostream></p>

<h1>include <cstdio></h1>

<p>using namespace std;</p>

<p>int main() {</p>

<pre><code>int testcases, N, sum;
int s[1011];

cin &gt;&gt; testcases;

for (int caseNr = 1; caseNr &lt;= testcases; caseNr++) {
    cin &gt;&gt; N;

    /** the sum of all points of all contestants*/
    sum = 0;

    for (int i = 0; i &lt; N; i++) {
        cin &gt;&gt; s[i];
        sum += s[i];
    }

    printf("Case #%d:", caseNr);

    for (int contestant = 0; contestant &lt; N; contestant++) {
        // approximate the minimum for each contestant
        double low = 0, high = 1;

        // increase the accuracy 100 times
        for (int j = 0; j &lt; 100; j++) {
            double mid = (low + high) / 2;
            double me = s[contestant] + mid * sum;
            double remaining = 1 - mid;

            for (int k = 0; k &lt; N &amp;amp;&amp;amp; remaining &gt; 0; k++) {
                if (k != contestant &amp;amp;&amp;amp; s[k] &lt; me) {
                    // the contestant k needs at least
                    // this part of all audience votes
                    remaining -= (me - s[k]) / sum;
                }
            }

            if (remaining &gt; 0) {
                low = mid;
            } else {
                high = mid;
            }
        }
        printf(" %.6lf", low * 100);
    }

    printf("\n");
}
</code></pre>

<p>}[/cpp]</p>

<h2>Tide Goes In, Tide Goes Out</h2>


<p>This one could be solved with Graphs. You calculate one Graph, where every node is one cell. Every cell / node is connected to adjacent cells. Every cell has a value which is the time when you can enter them.</p>

<p>After you've created the graph, you can make something like that:</p>

<div class="highlight"><pre><code class="python"><span class="n">graph</span> <span class="o">=</span> <span class="n">createGraph</span><span class="p">(</span><span class="n">floorHeight</span><span class="p">,</span> <span class="n">ceilingHeight</span><span class="p">)</span>
<span class="n">endReached</span> <span class="o">=</span> <span class="bp">False</span>
<span class="n">nodesReached</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">while</span> <span class="p">(</span><span class="ow">not</span> <span class="n">endReached</span><span class="p">):</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">getMinimumAdjacentNode</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">nodesReached</span><span class="p">)</span>
    <span class="n">nodesReached</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
<span class="k">return</span> <span class="n">maxTime</span><span class="p">(</span><span class="n">nodesReached</span><span class="p">)</span>
</code></pre></div>




<h2>Equal Sums</h2>


<p>A trivial solution for the small one is to try every combination. You might want to take a look at Pythonss <a href="http://docs.python.org/library/itertools.html#itertools.combinations">itertools.combinations()</a>.</p>

<h2>See also</h2>


<ul>
  <li>Wikipedia: <a href="http://en.wikipedia.org/wiki/Google_Code_Jam">Google Code Jam</a></li>
  <li><a href="http://www.go-hero.net/jam/12/">Google Code Jam Statistics</a></li>
</ul>



<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    processEscapes: true
  }
});
</script>
</div>

            <div class="footer">
    <div class="contact">
      <p>
        Martin<br />
        What You Are<br />
        you@example.com
      </p>
    </div>
    <div class="contact">
      <p>
        <a href="https://github.com/yourusername">github.com/yourusername</a><br />
        <a href="https://twitter.com/yourusername">twitter.com/yourusername</a><br />
      </p>
    </div>
  </div>

        </div>
    </body>
</html>
